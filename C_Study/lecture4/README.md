### 메모리의 저장 된 주소 값 확인

---

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);

}
-> 0x7ffd1921a72c
```

### 포인터

---

`*p = &n;`  과 같은 명령어를 C에서 입력 하면 메모리에 저장 되어있는 주소 값을 얻을 수 있었다.

이 과정은 `*p` 라는 포인터를 획득하고, `&{변수}` 로 메모리 주소를 가져오는 형태가 된다.

![image](https://github.com/LeeJuHwan/Basic/assets/118493627/d74646d1-09b0-4e14-afe5-624dc16f670a)

- 포인터는 포인터를 가르킬 수 있다. 그 것은 **로 표기하며 이중 포인터라고 표현한다.

`string s = “Hi!”;` 이러한 문자열을 입력 하면, C는 char타입의 캐릭터 문자를 1개씩 배열로 받아들인다. 값은 `H`, `i`, `!`, `\0` 으로 모두 각자 메모리 주소 값을 가지고 있지만 실제 문자열에 저장 된 `‘s’` 는 문자들의 배열에 첫번째 메모리 주소 값을 갖게된다. 

이러한 문자열에 대한 메모리 저장 방식은 왜, 3가지의 변수가 쓰이지 않았고 왜, 첫번째 문자의 주소 값만 갖고 있을까?

- 문자열은 항상 null로 종료 하기 때문에 첫번째 메모리 주소를 얻고, null 데이터(`\0`)가 나올 때 까지 출력하면 된다.

하지만! 지금 까지 C에서는 string이라는 것은 존재 하지 않았다. 문자배열의 포인터를 사용 했기 때문에 문자열 처럼 보여진 것이다.

그래서, 이 코드는 서로 같다.

```python
// string s = "HI!";
    char *s = "Hi!";
    printf("%s\n", s);
```

→ 여기서 string을 구현 하고 싶다면?

```c
typedef char *string;
```

구조체를 이용 하여 string 타입은 문자배열들의 포인터 라고 명시 해주면 결국 string 타입을 만들어 낼 수 있었다.

→ 문자열에 대한 메모리 주소 값 확인하기

```c
int main(void)
{
		char *s = "HI!";
    printf("%p\n", s);
    printf("%p\n", &s[0]);

}
0x563ebf838004
0x563ebf838004
```

> 포인터 역참조
> 

이렇게 포인터는 해당 변수에 있는 메모리 주소 값을 가지고 있다. 하지만, 이 주소 값이 의미하는 것은 그 안에 담겨져 있는 정수, 문자열이 필요할 뿐 메모리 주소를 활용 하기는 아직 어렵다. 이럴 때 쓰일 수 있는게 역참조 방식

```c
int main(void)
{
    int num = 50;
    int *p = &num;
    printf("%i\n", *p);

}
-> memory/ $ make addresses 
memory/ $ ./addresses 
50
```

이렇게, 포인터를 지정하고 메모리 주소 값을 얻은 다음 역참조 하게 되면 아래와 같이 변수를 호출 할 수 있다.

> 포인터 연산
> 

문자배열의 포인터는 위에서 봤듯이 캐릭터의 첫번째 문자 주소를 갖고 있는 포인터다. 하지만, 두번째 ~ 세번째 등 등 그 이후에 있는 주소값을 역참조 하려면 어떻게 해야 할까?

일단, 머릿속에 있는 일방적인 인덱스 방법으로는 역참조가 불가능 했고 포인터 연산을 이용 하면 그 이후에 값도 가지고 올 수 있었다.

```c
int main(void)
{
		char *s = "HI!";
    printf("%c\n", *s);
    printf("%c\n", *(s+1));
    printf("%c\n", s[2]);

}
memory/ $ ./addresses 
H
I
!
```